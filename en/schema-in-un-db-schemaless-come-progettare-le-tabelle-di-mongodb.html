<!DOCTYPE html>
<html lang="en">
<head>
        <meta charset="utf-8" />
        <meta name=viewport content="width=device-width, initial-scale=1">
        <title>Schema in un db schemaless (come progettare le tabelle di MongoDB)</title>
        <link rel="stylesheet" href="http://blog.gambuzzi.it/en/theme/css/main.css" />

        <!--[if IE]>
            <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
        <![endif]-->
        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
        <script src="http://blog.gambuzzi.it/en/theme/js/fuzzyset.js"></script>
		<meta name="google-site-verification" content="62DfkLCugSzm-vW0NRbnM2aCMcGu7uqfsXjED71GNbI" />
    <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-54060223-1']);
    _gaq.push(['_trackPageview']);
    (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
    </script>
<script type="text/javascript">
  var _gauges = _gauges || [];
  (function() {
    var t   = document.createElement('script');
    t.type  = 'text/javascript';
    t.async = true;
    t.id    = 'gauges-tracker';
    t.setAttribute('data-site-id', '550ab326de2e26670a017635');
    t.setAttribute('data-track-path', 'https://track.gaug.es/track.gif');
    t.src = 'https://track.gaug.es/track.js';
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(t, s);
  })();
</script>
</head>

<body id="index" class="home lang- 1.0.0">
        <header id="banner" class="body">
                <h1><a href="http://blog.gambuzzi.it/en/">Code's Fragment  <strong>and various amenities</strong></a></h1>

                <div class="langchange"><ul>
                        <li><a href="http://blog.gambuzzi.it"><img src="http://blog.gambuzzi.it/en/theme/images/it.png" alt="it"/></a></li>
                    <!-- separator -->
                    </ul>
                </div>

                <form id="headsearch" action='/search.html' method="GET">search: <input type="text" name="q" id="q0" /></form>

                <nav><ul>
                    <li class="active"><a href="http://blog.gambuzzi.it/en/category/mix.html">Mix</a></li>
                    <li><a href="http://blog.gambuzzi.it/en/category/php.html">Php</a></li>
                    <li><a href="http://blog.gambuzzi.it/en/category/python.html">Python</a></li>
                    <li><a href="http://blog.gambuzzi.it/en/category/windows.html">Windows</a></li>
                </ul></nav>
        </header><!-- /#banner -->
<section id="content" class="body">
  <article>
    <header>
      <h1 class="entry-title">
        <a href="http://blog.gambuzzi.it/en/schema-in-un-db-schemaless-come-progettare-le-tabelle-di-mongodb.html" rel="bookmark"
           title="Permalink a Schema in un db schemaless (come progettare le tabelle di MongoDB)">Schema in un db schemaless (come progettare le tabelle di MongoDB)</a></h1>
<a href="http://twitter.com/share" class="twitter-share-button" data-count="horizontal" data-via="gbinside">Tweet</a><script type="text/javascript" src="//platform.twitter.com/widgets.js"></script>
    </header>

    <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2015-01-21T00:00:00">
                Pubblicato: 21 01 2015
        </abbr>

        <address class="vcard author">
                Da                         <a class="url fn" href="http://blog.gambuzzi.it/en/author/roberto-gambuzzi.html">Roberto Gambuzzi</a>
        </address>
<p>In <a href="http://blog.gambuzzi.it/en/category/mix.html">Mix</a>. </p>
<p>tags: <a href="http://blog.gambuzzi.it/en/tag/mix.html">mix</a> <a href="http://blog.gambuzzi.it/en/tag/mongodb.html">mongodb</a> <a href="http://blog.gambuzzi.it/en/tag/db.html">db</a> </p>
</footer><!-- /.post-info -->      <p>Nonostante il singolo record( o meglio <em>documento</em>) di MongoDB sia schemaless, per comodità applicativa ovviamente si dividono i documenti in collections, più o meno omogenee come tracciato. Il vantaggio dell'essere schemaless si ha quando si vuole aggiungere un campo che non si era previsto o quando si vuolo "embeddare" altri documenti o oggetti come array.</p>
<p>Come strutturare quindi il proprio domino di dati con MongoDB?</p>
<p>Due regole molto generali, ma che vi possono aiutare moltissimo sono:</p>
<ul>
<li>se state strutturando le tabelle come fareste su un db relazionale, state sbagliando.</li>
<li>strutturate i dati in funzione di come li accederete dalla applicazione; esempio: se avete due collections <code>studenti</code> e <code>professori</code>, la relazione può essere sia dalla studente al professore, sia viceversa. Ha senso mettere il riferimento su una o sull'altra (o su tutte e due) in funzione di come l'applicazione cerca i dati. Se dalla scheda dello studente (in interfaccia) si deve saltare al professore e mai viceversa si metterà la relazione sullo studente.</li>
</ul>
<p>Vediamo con ordine come <em>tradurre</em> le relazioni che incontriamo in un tradizionale DB relazione in qualcosa di più adatto a MongoDB (e alla vostra applicazione):</p>
<h2>Relazioni 1 a 1</h2>
<p>In un db relazione questo tipo di relazione ha già poco senso, nel senso che basterebbe aggiungere colonne ad una tabella già esistente, anziché farne una altra in relazione 1a1.</p>
<p>In MongoDb gli unici due motivi per dividere in pratica un documento/record in 2 diverse collections possono essere:</p>
<ul>
<li>Il singolo documento supera i 16MB, limite del BSON usato da MongoDB;</li>
<li>Parte del documento che si vuole accedere non serve con la stessa frequenza del resto e rischia di appesantire il recupero del documento dal db.<ul>
<li>Esempio: abbiamo il catalogo di un ecommerce, che nel singolo documento, che rappresenta il singolo prodotto, contiene (in pdf) anche la pagina del catalogo cartaceo in cui compare e magari qualche software (come un driver). <em>Qui</em> conviene separare gli attributi del prodotto in 2 categorie; gli attributi (che si spera siano di piccole dimensioni) che servono in galleria prodotto, che saranno sempre caricati e potranno essere usati per gli ordinamenti, e gli attributi <em>extra</em>, che renderebbero lento il caricamento in galleria, ma che servono in visualizzazione della scheda dettagli del prodotto.</li>
</ul>
</li>
</ul>
<p>Anche qui la logica della vostra applicazione influisce sulla struttura dei dati.</p>
<p>A differenza di quanto ci hanno sempre insegnato coi DB relazionali, il db <em>NON</em> deve essere agnostico rispetto alla applicazione da implementare, nemmeno alla sua interfaccia. Se 2 diversi dati non vengono mai visualizzati nella stessa pagina/schermata, è inutile tenerli nello stesso documento o, addirittura, metterli in relazione.</p>
<h2>Relazioni 1 a N</h2>
<p>Anche qui dobbiamo ragionare in funzione di come i dati verranno visualizzati e aggiornati.
Ipotizziamo un articolo di un blog, commenti e tag.
Sui commenti dei singoli articoli, difficilmente faremo accessi singolarmente; non ci sarà una pagina con l'elenco di tutti i commenti.
I commenti verranno con buona probabilità visualizzati <em>solo</em> insieme all'articolo a cui sarebbero in relazione 1 a N. Inoltre difficilmente supereremo i 16MB fra articolo e commenti.</p>
<p><em>Quindi</em> i commenti possono essere embeddati come sottodocumento nell'articolo</p>
<div class="highlight"><pre><span class="nx">articolo</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">_id</span> <span class="o">:</span> <span class="nx">ObjectId</span><span class="p">(</span><span class="s2">&quot;54bc49638379934d5de98d7d&quot;</span><span class="p">),</span>
    <span class="nx">titolo</span> <span class="o">:</span> <span class="s2">&quot;Schema in un db schemaless (come progettare le tabelle di MongoDB)&quot;</span><span class="p">,</span>
    <span class="nx">corpo</span> <span class="o">:</span> <span class="s2">&quot;Nonostante il singolo record di MongoDB ...&quot;</span><span class="p">,</span>
    <span class="nx">commenti</span> <span class="o">:</span> <span class="p">[{</span>
        <span class="nx">autore</span><span class="o">:</span> <span class="s2">&quot;Anonimo veneziano&quot;</span><span class="p">,</span>
        <span class="nx">email</span> <span class="o">:</span> <span class="s2">&quot;none@example.com&quot;</span><span class="p">,</span>
        <span class="nx">commento</span><span class="o">:</span> <span class="s2">&quot;non sono concorde...&quot;</span>
      <span class="p">},</span> <span class="p">{</span>
        <span class="nx">autore</span><span class="o">:</span> <span class="s2">&quot;Anonimo veneziano&quot;</span><span class="p">,</span>
        <span class="nx">email</span> <span class="o">:</span> <span class="s2">&quot;none@example.com&quot;</span><span class="p">,</span>
        <span class="nx">commento</span><span class="o">:</span> <span class="s2">&quot;continuo a non essere concorde...&quot;</span>
      <span class="p">}],</span>
    <span class="nx">tags</span><span class="o">:</span> <span class="p">[</span><span class="s2">&quot;mix&quot;</span><span class="p">,</span> <span class="s2">&quot;mongodb&quot;</span><span class="p">,</span> <span class="s2">&quot;db&quot;</span><span class="p">]</span>
<span class="p">}</span>
</pre></div>


<p>Vedremo poi come comportarci coi <em>tags</em> che sono in relazione "N a M"</p>
<p>Riassumendo si può precedere ad "embeddare" i documenti relazionati in "1 a N" quando:
<em> i documenti non superano 16MB (compreso documento principale).
</em> i documenti sono acceduti sempre assieme al documento principale.</p>
<p>Negli altri casi si procede, come faremmo con un normale db relazionale, a mettere l'object_id dell'articolo come valore del commento</p>
<div class="highlight"><pre><span class="nx">commento</span> <span class="o">=</span> <span class="p">{</span>
        <span class="nx">_id</span><span class="o">:</span> <span class="nx">ObjectId</span><span class="p">(</span><span class="s2">&quot;a4bc49a53279934d5de98231&quot;</span><span class="p">),</span>
        <span class="nx">autore</span><span class="o">:</span> <span class="s2">&quot;Anonimo veneziano&quot;</span><span class="p">,</span>
        <span class="nx">email</span> <span class="o">:</span> <span class="s2">&quot;none@example.com&quot;</span><span class="p">,</span>
        <span class="nx">commento</span><span class="o">:</span> <span class="s2">&quot;non sono concorde...&quot;</span>
        <span class="nx">articolo</span><span class="o">:</span> <span class="nx">ObjectId</span><span class="p">(</span><span class="s2">&quot;54bc49638379934d5de98d7d&quot;</span><span class="p">)</span>
      <span class="p">}</span>
</pre></div>


<h2>Relazioni "N a M"</h2>
<p>Le relazioni N a M, many-to-many, molti-a-molti, sono spesso delle relazioni pochi-a-pochi.</p>
<p>Prendiamo l'esempio classico della relazione fra libri e autori.</p>
<p>In questo classico esempio avremo libri scritti da pochi autori (di solito 1) e autori che scrivono (in media) pochi libri. Ci sono autori che scrivono molti libri, ma sono statisticamente una minoranza, rispetto a coloro che hanno scritto 1 o 2 libri.</p>
<p>Nel libro possiamo avere un campo per l'array degli autori; nell'autore possiamo avere un campo per l'array dei libri.</p>
<div class="highlight"><pre><span class="nx">libro</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">_id</span> <span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
  <span class="c1">//....</span>
  <span class="nx">autori</span><span class="o">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="p">}</span>

<span class="nx">autore</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">_id</span><span class="o">:</span> <span class="mi">2</span><span class="p">,</span>
  <span class="c1">//....</span>
  <span class="nx">libri</span><span class="o">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">19</span><span class="p">]</span>
<span class="p">}</span>
</pre></div>


<p>Circa come si farebbe in un db relazionale, senza pero' una tabella aggiuntiva con le sole relazioni.</p>
<p>Nella gestione delle array (che spesso non saranno mai molto grosse) ci viene incontro MongoDB con tutta una serie di funzioni.</p>
<p>Inoltre questa struttura è ridondante, ancora una volta per venire incontro alle logiche di visualizzazione della app in sviluppo. Facilmente si vorrà saltare da un libro al suo autore e da un autore al suo elenco di libri.</p>
<p>Altro pro della struttura ridondante è una forma di controllo di errore. In MongoDB non ci sono <code>constraints</code>, quindi è l'applicazione a doversi preoccupare dell'integrità dei dati, non il DB.</p>
<p>Prendiamo una relazione fra articoli a catalogo e carrello, senza storicizzazione dell'articolo (che non andrebbe fatta a livello di carrello, ma solo alla conferma dell'ordine). Un carrello può avere più articoli e un articolo può essere in più carrelli (di diversi utenti). Sulla relazione in un relazionale classico, ci sarebbe la relazione come field aggiuntivo.</p>
<div class="highlight"><pre>    +----------+        /<span class="se">\ </span>       +----------+
    |          |       /  <span class="se">\ </span>      |          |
    |          |  n   /    <span class="se">\ </span>  m  |          |
    | articoli |-----&lt;  nm  &gt;-----| carrelli |
    |          |      <span class="se">\ </span>   /      |          |
    |          |  qta--<span class="se">\ </span> /       |          |
    +----------+        <span class="se">\/</span>        +----------+
</pre></div>


<p>Qui avremo tipicamente un carrello con pochi articoli e gli articoli in molti carrelli (se il nostro ecommerce è un B2C e ha un buon successo).</p>
<p>Sempre tipicamente vorremo avere un elenco del contenuto del carrello e quasi mai un elenco dei carrelli che contengono un determinato prodotto (salvo per motivi statistici, ma per quelli non si fanno query sul db di produzione, ma su una replica statica, magari su una altro motore DB).</p>
<p>Quindi</p>
<div class="highlight"><pre><span class="nx">carrello</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">_id</span> <span class="o">:</span> <span class="nx">ObjectId</span><span class="p">(</span><span class="s2">&quot;54bc49638371231231e98d7d&quot;</span><span class="p">),</span>
    <span class="nx">articoli</span> <span class="o">:</span> <span class="p">{</span>
      <span class="s2">&quot;SW18-22&quot;</span> <span class="o">:</span> <span class="mi">2</span><span class="p">,</span>
      <span class="s2">&quot;JO350AA&quot;</span> <span class="o">:</span> <span class="mi">3</span><span class="p">,</span>
    <span class="p">},</span>
    <span class="nx">gran_totale</span><span class="o">:</span> <span class="p">{</span><span class="s1">&#39;EUR&#39;</span><span class="o">:</span> <span class="mf">1000.00</span><span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>Avremo 2 articoli con codice <code>SW18-22</code> e 3 con codice <code>JO350AA</code>, con articoli del tipo:</p>
<div class="highlight"><pre><span class="nx">articolo</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">_id</span> <span class="o">:</span> <span class="nx">ObjectId</span><span class="p">(</span><span class="s2">&quot;231e98d7d54bc49638371231&quot;</span><span class="p">),</span>
    <span class="nx">sku</span> <span class="o">:</span> <span class="s2">&quot;SW18-22&quot;</span><span class="p">,</span>
    <span class="nx">nome</span><span class="o">:</span> <span class="p">{</span> <span class="s2">&quot;it&quot;</span><span class="o">:</span> <span class="s2">&quot;Sturalavandini&quot;</span><span class="p">,</span> <span class="s2">&quot;en&quot;</span><span class="o">:</span> <span class="s2">&quot;Plunger&quot;</span> <span class="p">},</span>
    <span class="c1">//....</span>
<span class="p">}</span>
</pre></div>


<p>e magari un indice sullo <code>sku</code> dell'articolo.</p>
<p>Un altro dettaglio per un ecommerce potrebbe essere quello che il carrello attivo di un utente e sempre e solo 1, quindi il carrello non è linkato al customer (o viceversa), ma embeddato in esso.</p>
<div class="highlight"><pre><span class="nx">cliente</span> <span class="o">=</span> <span class="p">{</span>
    <span class="c1">//....</span>

    <span class="nx">carrello</span> <span class="o">:</span><span class="p">{</span>
      <span class="nx">articoli</span> <span class="o">:</span> <span class="p">{</span>
        <span class="s2">&quot;SW18-22&quot;</span> <span class="o">:</span> <span class="mi">2</span><span class="p">,</span>
        <span class="s2">&quot;JO350AA&quot;</span> <span class="o">:</span> <span class="mi">3</span><span class="p">,</span>
      <span class="p">},</span>
      <span class="nx">gran_totale</span><span class="o">:</span> <span class="p">{</span><span class="s1">&#39;EUR&#39;</span><span class="o">:</span> <span class="mf">1000.00</span><span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>Il gran_totale è storicizzato nel carrello e ricalcolato ogni volta che serve, per velocizzare la visualizzazione (anche qui una scelta di <em>tracciato</em> dettata da una esigenza di visualizzazione dell'applicazione)</p>
<p>Tornando ai tags degli articoli di un blog: salvare una array di <code>_id</code> che puntano ai tags ha il vantaggio che, se si vuole correggere un typo in un tag o rinominarlo, andremo ad aggiornare in un solo punto. Il principio di non replicare i dati nelle varie collections si applica anche a MongoDB, laddove ovviamente la replica non generi un vantaggio prestazionale tale da giustificare poi una procedura applicativa di sincronia dei dati fra le varie collections.</p>
<h2>Silver Bullet</h2>
<p>Non c'è quindi una soluzione magica per modellare le collections, ma come avete visto avere ben chiara in testa ogni parte della propria applicazione aiuta sempre. Un altro vantaggio di MongoDB è senza dubbio che al cambiare delle specifiche del cliente sull'applicazione, possiamo reagire più rapidamente al cambiamento di un DB relazionale (niente migration, salvo casi eccezionali, per intenderci).</p>
    </div><!-- /.entry-content -->

  </article>
</section>
        <section id="extras" class="body">
                <div class="blogroll">
                        <h2>blogroll</h2>
                        <ul>
                            <li><a href="http://python.org/">Python.org</a></li>
                            <li><a href="http://martinfowler.com/">Martin Fowler</a></li>
                            <li><a href="http://www.joelonsoftware.com/">Joel On Software</a></li>
                            <li><a href="http://alanstorm.com/">Alan Storm</a></li>
                        </ul>
                </div><!-- /.blogroll -->
                <div class="social">
                        <h2>social</h2>
                        <ul>

                            <li><a href="https://twitter.com/gbinside">Twitter</a></li>
                            <li><a href="https://github.com/gbinside">GitHub</a></li>
                        </ul>
                </div><!-- /.social -->
        </section><!-- /#extras -->

        <footer id="contentinfo" class="body">
                <address id="about" class="vcard body">
                &nbsp;
                </address><!-- /#about -->

                <p>&nbsp;</p>
        </footer><!-- /#contentinfo -->

<script type="text/javascript">
    var disqus_config = function () {
      this.language = "it";
    };
    var disqus_shortname = 'bloggambuzzi';
    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = '//' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
</script>
</body>
</html>